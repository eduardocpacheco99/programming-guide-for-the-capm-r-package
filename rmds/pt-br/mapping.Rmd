```{r knitsetup, echo=FALSE, results='hide', warning=FALSE, message=FALSE, cache=FALSE}
library(knitr)
opts_knit$set(base.dir='./')
opts_chunk$set(prompt=TRUE, comment='', fig.path='figures/')
options(width = 66)
```

```{r,results='hide',echo=FALSE}
library(capm)
psu.ssu <- read.csv(file = 'psu.ssu.csv')
set.seed(4)
pilot.psu <- SamplePPS(psu.ssu = psu.ssu,
                       psu = 10,
                       write = FALSE)
set.seed(4)
pilot.ssu <- SampleSystematic(
    psu.ssu = pilot.psu,
    su = 5, write = FALSE)
```

## Mapeando unidades amostrais

Para o desenho por conglomerados em dois estágios (ver secção anterior), quase sempre é necesario mapear as UPA para saber a donde debemos ir. Afortunadamente o `capm` tem uma função para mapear as UPA. Se temos um shapefile das UPA estamos feitos - como neste caso. Na área de trabalho há cinco arquivos chamados "santos", cada um com uma extenção diferente. Todos esses arquivos são uma representação shapefile das UPA da área de amostragem (cidade de Santos). Esses arquivos também foram obtidos no IBGE (ver seção anterior).

```{r,eval=FALSE}
MapkmlPSU(shape = 'santos',
          psu = pilot.psu[, 1],
          id = 1)
```

`MapkmlPSU` cria um arquivo "kml" para cada UPA selecionada e um "kml" com todas as UPA selecionadas. Esses arquivos podem ser abertos com Google Earth apenas cliando sobre os mesmos. [QGIS](http://qgis.org) é uma ferramenta de código aberto que também "renderiza" camadas de base para os arquivos "kml". 

É claro que o R nós permite plotar as localizações das UPA selecionadas. Não se preocupen se não entendem o seguiente fragmento de código, pois é apenas outra alternativa para Google Earth e QGIS.

Se aparece o erro "503 Service Unavailable", devemos intentar mais tarde para ver se o servidor OSM volta a funcionar (ver a página de ajuda de `get_openstreetmap`).

```{r map_all_psu}
# o pacote rgeos deve estar instalado.
library(rgdal); library(ggmap); library(ggsn)
santos <- readOGR(dsn = '.', layer = 'santos')
santos.pilot <- santos[
    as.character(santos@data[ , 1]) %in%
        pilot.psu[ , 1], ]
santos.pilot <- spTransform(
    santos.pilot,
    CRS('+init=epsg:4326'))
santos.pilot@data$id <-
    rownames(santos.pilot@data)
santos.pilot.points <- fortify(santos.pilot,
                               region = "id")
santos.pilot.df <- merge(santos.pilot.points,
                         santos.pilot@data,
                         by = "id")

osm.all.psu <- get_openstreetmap(
    bbox = c(-46.386, -23.991, -46.298, -23.929),
    scale = 34000, color = 'bw')

ggmap(osm.all.psu, extent = 'device') + 
    geom_polygon(
        data = santos.pilot.df,
        aes(x = long, e = lat, fill = PSU)) +
    coord_equal() +
    geom_path(data = santos.pilot.df,
              aes(long, lat, group = group),
              color = 'yellow', size = 1.2) +
    scalebar(santos.pilot.df, 'bottomleft',
             dist = 1, dd2km = T,
             model = 'WGS84', st.size = 3) +
    north(santos.pilot.df, symbol = 15)
    
```

Sem importar o método usado para producir os mapas, devemos desenhar um percurso no mapa de cada UPA para poder ir por todas as ruas. Podemos definir um domicílio em um ponto arbitrário (localização inferior esquerda) como o primeiro domicílio e a partir do mesmo, podemos seguir o percurso contando os domicílios (incluindo os dois lados dos fragmentos de rua totalmente contidos na UPA).  

O seguiente mapa mostra a quarta UPA selecionada.

```{r map_4th_psu}
osm.psu4 <- get_openstreetmap(
    bbox = c(-46.349, -23.962, -46.345, -23.957),
    scale = 5000)
ggmap(osm.psu4) +
    geom_polygon(data = santos.pilot[4, ],
                 aes(x = long, e = lat),
                 fill = NA,
                 color = 'yellow', size = 2) +
    coord_equal()
```
